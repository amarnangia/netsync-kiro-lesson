"""
Stock Data Explorer - A Streamlit Web Application

This application provides an interactive interface for visualizing stock price data
through dot plots and fetching real historical data from external APIs.

Development Stages:
- Stage 1 (Completed): Mock data generation and visualization with dot plots
- Stage 2 (Current): API integration to fetch and display raw historical stock data
- Stage 3 (Future): Data processing and integration with visualizations

Stage 2 Features:
- Fetches up to 2 years of historical stock data from Massive stock market API
- Implements rate limiting (5 calls per minute)
- Displays raw API responses in formatted JSON
- Maintains separation from Stage 1 mock data visualizations

API Configuration:
- RECOMMENDED: Add your API key to the .env file (copy from .env.example)
- Alternative: Set MASSIVE_API_KEY environment variable
- Alternative: Replace "YOUR_API_KEY_HERE" in the API_KEY constant
- Never commit your actual API key to version control (.env is in .gitignore)

Author: Generated by Kiro
Date: 2026-01-20
"""

# ============================================================================
# IMPORTS
# ============================================================================

import streamlit as st
import random
import os
import requests
from typing import Tuple, List, Optional, Dict, Any
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# ============================================================================
# CONSTANTS
# ============================================================================

# Predefined list of 20 major stock tickers
STOCK_TICKERS = [
    "AAPL", "GOOGL", "MSFT", "AMZN", "TSLA",
    "META", "NVDA", "JPM", "V", "WMT",
    "JNJ", "PG", "MA", "HD", "DIS",
    "BAC", "NFLX", "ADBE", "CRM", "INTC"
]

# ============================================================================
# API CONFIGURATION (STAGE 2)
# ============================================================================

# IMPORTANT: Configure your Massive stock market API key
# Option 1 (RECOMMENDED): Add your key to the .env file:
#   MASSIVE_API_KEY=your_actual_key_here
# Option 2: Set the MASSIVE_API_KEY environment variable
# Option 3: Replace "YOUR_API_KEY_HERE" below with your actual API key
# WARNING: Never commit your actual API key to version control
API_KEY = os.getenv("MASSIVE_API_KEY", "YOUR_API_KEY_HERE")

# API base URL for Massive stock market API
API_BASE_URL = "https://api.massive.com"

# Rate limiting: 5 calls per minute = 12 seconds between calls
RATE_LIMIT_SECONDS = 12

# ============================================================================
# DATA GENERATION FUNCTIONS
# ============================================================================

@st.cache_data
def generate_mock_stock_data(ticker: str, num_points: int = 30) -> Tuple[List[int], List[float], List[float]]:
    """
    Generate mock stock price data for visualization purposes.
    
    This function creates deterministic mock data based on the ticker symbol,
    ensuring the same ticker always produces the same data. The data simulates
    realistic stock price patterns with daily high and low prices.
    
    Args:
        ticker: Stock ticker symbol (e.g., "AAPL", "GOOGL")
        num_points: Number of data points to generate (default: 30)
    
    Returns:
        Tuple containing:
        - days: List of day numbers [1, 2, 3, ..., num_points]
        - high_prices: List of daily high prices
        - low_prices: List of daily low prices
        
    Invariants:
        - len(days) == len(high_prices) == len(low_prices)
        - high_prices[i] >= low_prices[i] for all i
        - All prices are positive values
    """
    # Use ticker as seed for deterministic random generation
    # Convert ticker string to a numeric seed
    seed = sum(ord(char) for char in ticker)
    random.seed(seed)
    
    # Generate day numbers
    days = list(range(1, num_points + 1))
    
    # Generate base price in realistic range ($50-$500)
    base_price = random.uniform(50, 500)
    
    # Generate price data with realistic volatility
    high_prices = []
    low_prices = []
    current_price = base_price
    
    for _ in range(num_points):
        # Add random walk component (-5% to +5% daily change)
        price_change = current_price * random.uniform(-0.05, 0.05)
        current_price = max(10, current_price + price_change)  # Ensure price stays above $10
        
        # Generate daily high and low around current price
        # High is 0-3% above current price
        daily_high = current_price * random.uniform(1.0, 1.03)
        
        # Low is 0-3% below current price
        daily_low = current_price * random.uniform(0.97, 1.0)
        
        # Ensure high >= low (should always be true by construction, but verify)
        if daily_high < daily_low:
            daily_high, daily_low = daily_low, daily_high
        
        high_prices.append(round(daily_high, 2))
        low_prices.append(round(daily_low, 2))
    
    return days, high_prices, low_prices

# ============================================================================
# API FETCHER FUNCTIONS (STAGE 2)
# ============================================================================

def fetch_stock_data(ticker: str, api_key: str) -> Optional[Dict[str, Any]]:
    """
    Fetch historical stock data from the Massive stock market API.
    
    This function implements rate limiting (5 calls per minute) and handles
    various error conditions. It returns raw API response data without processing.
    
    Args:
        ticker: Stock ticker symbol (e.g., "AAPL", "GOOGL")
        api_key: API authentication key
    
    Returns:
        Dictionary containing raw API response, or None if request fails
        
    Rate Limiting:
        Enforces minimum 12-second delay between API calls
        Uses st.session_state.last_api_call_time to track timing
    
    Error Handling:
        - Returns None if API key is placeholder value
        - Returns None if rate limit not met
        - Returns None on connection errors, timeouts, or HTTP errors
        - Returns None if response is empty or malformed
    """
    import time
    from datetime import datetime, timedelta
    
    # Check if API key is configured
    if api_key == "YOUR_API_KEY_HERE":
        return None
    
    # Check rate limiting
    current_time = time.time()
    if st.session_state.last_api_call_time is not None:
        time_since_last_call = current_time - st.session_state.last_api_call_time
        if time_since_last_call < RATE_LIMIT_SECONDS:
            # Rate limit not met - return None
            return None
    
    # Calculate date range (up to 2 years of historical data)
    end_date = datetime.now()
    start_date = end_date - timedelta(days=730)  # 2 years = ~730 days
    
    # Build API request URL for Massive aggregates endpoint
    # Format: /v2/aggs/ticker/{ticker}/range/{multiplier}/{timespan}/{from}/{to}
    # Example: /v2/aggs/ticker/AAPL/range/1/day/2024-01-01/2026-01-20
    url = f"{API_BASE_URL}/v2/aggs/ticker/{ticker}/range/1/day/{start_date.strftime('%Y-%m-%d')}/{end_date.strftime('%Y-%m-%d')}"
    
    # API key can be passed as query parameter or header
    params = {
        "apiKey": api_key  # Massive uses 'apiKey' parameter
    }
    
    try:
        # Make HTTP GET request with timeout
        response = requests.get(url, params=params, timeout=10)
        
        # Check for HTTP errors
        response.raise_for_status()
        
        # Parse JSON response
        data = response.json()
        
        # Update last API call timestamp
        st.session_state.last_api_call_time = current_time
        
        # TODO Stage 3: Process and transform this data
        # For now, return raw response
        return data
        
    except requests.exceptions.ConnectionError:
        # Connection failed
        return None
    except requests.exceptions.Timeout:
        # Request timed out
        return None
    except requests.exceptions.HTTPError:
        # HTTP error (4xx, 5xx)
        return None
    except requests.exceptions.JSONDecodeError:
        # Malformed JSON response
        return None
    except Exception:
        # Catch-all for unexpected errors
        return None

# ============================================================================
# VISUALIZATION FUNCTIONS
# ============================================================================

def display_raw_api_data(api_response: Dict[str, Any]) -> None:
    """
    Display raw API response data in formatted JSON.
    
    Args:
        api_response: Dictionary containing raw API response data
    """
    with st.expander("Raw API Data (Stage 2)", expanded=True):
        st.json(api_response)


def display_api_error(error_type: str, message: str) -> None:
    """
    Display appropriate error messages for API failures.
    
    Args:
        error_type: Type of error ("connection", "auth", "rate_limit", "empty", "timeout")
        message: Detailed error message to display
    """
    if error_type in ["connection", "auth", "timeout"]:
        st.error(message)
    elif error_type == "rate_limit":
        st.warning(message)
    elif error_type == "empty":
        st.info(message)
    else:
        st.error(message)


def display_dot_plots(days: List[int], high_prices: List[float], low_prices: List[float]) -> None:
    """
    Display dot plots for high and low stock prices.
    
    Args:
        days: List of day numbers
        high_prices: List of daily high prices
        low_prices: List of daily low prices
    """
    import pandas as pd
    
    # Create DataFrame for high prices
    high_df = pd.DataFrame({
        'Day': days,
        'Price': high_prices
    })
    
    # Display high prices dot plot
    st.subheader("High Prices")
    st.scatter_chart(high_df, x='Day', y='Price', color=None)
    
    # Create DataFrame for low prices
    low_df = pd.DataFrame({
        'Day': days,
        'Price': low_prices
    })
    
    # Display low prices dot plot
    st.subheader("Low Prices")
    st.scatter_chart(low_df, x='Day', y='Price', color=None)

# ============================================================================
# MAIN APPLICATION
# ============================================================================

def main():
    """Main application entry point"""
    # Initialize session state for rate limiting
    if 'last_api_call_time' not in st.session_state:
        st.session_state.last_api_call_time = None
    
    # Display application title
    st.title("Stock Data Explorer")
    
    # Stock selector with searchable dropdown
    selected_stock = st.selectbox(
        "Select a stock ticker:",
        options=STOCK_TICKERS,
        index=0  # Default to first ticker (AAPL)
    )
    
    # Display plots only if a stock is selected
    if selected_stock:
        # ====================================================================
        # STAGE 1: Mock Data Visualization
        # ====================================================================
        
        # Generate mock data for the selected stock
        days, high_prices, low_prices = generate_mock_stock_data(selected_stock)
        
        # Display the dot plots
        display_dot_plots(days, high_prices, low_prices)
        
        # ====================================================================
        # STAGE 2: Real-Time API Data
        # ====================================================================
        
        st.divider()
        st.subheader("Stage 2: Real-Time API Data")
        
        # Check if API key is configured
        if API_KEY == "YOUR_API_KEY_HERE":
            st.warning(
                "⚠️ API key not configured. Please set your API key to fetch real stock data.\n\n"
                "**Option 1:** Set the `MASSIVE_API_KEY` environment variable\n\n"
                "**Option 2:** Edit `stock_explorer.py` and replace `YOUR_API_KEY_HERE` with your actual API key"
            )
        else:
            # Check rate limiting
            import time
            if st.session_state.last_api_call_time is not None:
                time_since_last_call = time.time() - st.session_state.last_api_call_time
                if time_since_last_call < RATE_LIMIT_SECONDS:
                    seconds_remaining = int(RATE_LIMIT_SECONDS - time_since_last_call)
                    display_api_error(
                        "rate_limit",
                        f"⏳ Rate limit: Please wait {seconds_remaining} seconds before making another API request."
                    )
                else:
                    # Fetch data from API
                    with st.spinner("Fetching data from API..."):
                        api_data = fetch_stock_data(selected_stock, API_KEY)
                    
                    if api_data is not None:
                        # Display raw API response
                        display_raw_api_data(api_data)
                        # TODO Stage 3: Connect API data to visualizations
                    else:
                        display_api_error(
                            "connection",
                            "❌ Failed to fetch data from API. Please check your internet connection and API key."
                        )
            else:
                # First API call - no rate limiting needed
                with st.spinner("Fetching data from API..."):
                    api_data = fetch_stock_data(selected_stock, API_KEY)
                
                if api_data is not None:
                    # Display raw API response
                    display_raw_api_data(api_data)
                    # TODO Stage 3: Connect API data to visualizations
                else:
                    display_api_error(
                        "connection",
                        "❌ Failed to fetch data from API. Please check your internet connection and API key."
                    )
    else:
        # Display helpful message if no stock is selected (edge case)
        st.info("Please select a stock ticker to view price data.")

if __name__ == "__main__":
    main()
